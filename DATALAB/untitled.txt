   
   
   
   
   
   
   /* ACTUAL CODE FOR INTERVIEW
    int sum;
    int T; // holds the value for a operation
    int overflow; // holds the value of whether it overflows or not
    int a= 0x80; //lower bound - creats a binary value of a single 1 followed by 7 zeros 
    a = a << 24; // then we shift that to get 31 zeros
    int V = 0x7f; //upper bound - greats a binary value of a single zero with 7 ones
    int Vo = 0xff; // creats a binary number with 8 1s to use to get all ones in our shifted V int
    V = V << 8 | Vo; // shift by 8 and or it to get all ones then repeat 2 more times
    V= V << 8 | Vo;
    V= V << 8 | Vo;
    int mask = 0x80; // creats a binary value that has a single 1 and 7 zeros
    mask = mask << 24; // shifts the mask to get 32 bits with a leading 1
    ///////////////// add ok
    int valueX = x; // 
    int valueY= y;
    valueX = valueX >>31;
    valueY = valueY >>31;
    valueX = valueX & 0x1;
    valueY = valueY & 0x1;
    int test = x + y; 
    sum = test; 
    test =test >> 31;
    int test2 = test & 0x1; // gets the most sig fig of the sum // in example we start with 1 and get a copy of v as our result
    overflow = ((valueY ^ test2) & (valueX ^ test2)); // this sees if we overflowed yet but we dont know if it was an positive overflow or a negative overflow. This checks to see if the most sig bit of test2 is the same as the original values in x and y's sig bit which would tell you if it overflowed at all but not in what way. If this returns true it did overflow if it returns false it did not overflow
    //////////////////////////////
    int sumSign = !(test2); // the logical not of the sig fig of the sum
    mask = (!overflow + ~0x00); // a bumch of 1s plus either a 0 or a 1 from the not overflow what that does is it either allows us to have all 1s still by adding nothing to it aka a 0 which we got from the noted 1 from overflow which means it did overflow OR it allows us to have all 0s by adding a 1 to it which we got from the overflow which returned a 0 meaning it did not overflow. SO this is a condition made from whether it overflowed
    int mask2 = (!sumSign +  ~0x00); // it takes the sign of the sum and nots it for the same reason above, this tells us the sign of the sum is neg or positive and it creates a usable condition based on that
    T = ((~mask2) & V)/*if mask is 0 it becomes all 1s and thus makes a copy of V */ /* | ((mask2) /*anded with the min which is all zeros which gets rid of it so the whole thing is zero & a); // if the sum is negative then it //// so now this whole thing is V
    mask = ((~mask) & sum) | ((mask) & T ); // this checks if it was a positive overflow or a negative overflow and what it returns is either the max postive or max negative number 
    return mask;
    */
    ///////////////////////////////////////////////////////////////////////////////////////////////////////// END OF CODE FOR INTERVIEW
    /*
    int sum;
    int T;
    int overflow;
    int a= 0x80; // creates a value with a leading number of one for sig fig
    a = a << 24; // shifts it by 24 
    int V = 0x7f; // creats a value with a leading number of 0 for sig fig
    int Vo = 0xff; // creats a calue of 8 ones
    V = V << 8 | Vo; // sets V to itself and shifts it by 8 creating 8 zeros at the end then ors it with the all ones to pull out the 8 bits of ones
    V= V << 8 | Vo; // sets V equal to itself and shifts it by 8 creating 8 zeros at the end then ors it with Vo to make those all ones
    V= V << 8 | Vo; // sets v equal to itself and shifts it by 8 creating 8 zeros at the end then orse it with Vo to make those all ones
    int mask = 0x80; // creats a mask with a leading value of 1 fallowed by 7 zeros
    mask = mask << 24; // sets the mask equal to itself then shifts it by 24 creating 24 zeros at the end. Now the total # of bits is 32
    ///////////////// ADD OKAY
    int valX = mask & x; // creates int called valX sets that equal to mask that is anded with x to pull out the significant bits from the x value????
    int valY = mask & y; // does the same as the above line but for why
    valX = !(!valX); // turns valx into a sing bit of either true or false
    valY = !(!valY); // does the same as the above line except for valY
    int case1 = !(valX ^ valY); // stores the bit of either true or false aka zero or 1, of the exclusive or which if they are the same it returns 0 if they are different it returns 1.
    int test1 = x +y; // adds the two passed in values x and y. which if its a 0 0 add its still 0 if its a 0 1 add its 1 and if its 1 1 it is zero and the 1 carrys over to the next bit addition in the next colum
    sum = test1; // sets sum to test 1 so we can use a modified version of the sum as well as an un modified version later on
    int testResult = test1 & mask; // ands the new binary number that was derived by adding the x and y and the mask which is 42 bits that leads with 1 thus swithcing the sig fig if its 0 in the test to a 0 and if it is 1 in both test and mask it keeps the 1
    testResult = !(!testResult); // reduces the whole results of zeros and ones to either 1 or 0 aka either true or false, then the second exterieor ! switches it to the obososit, thus if the first made it 1 the second makes it 0 and vice versa
    int case2 = (valX ^ testResult); // sets case2 to the exlusive or of valx and testresult which means if they share a value it sets it to 0 and if they dont then it is 1
    overflow = (case1 & case2); // take case1 and case 2 and and them meaning if they are both true than it returns a 1 and if they are 0 and 1 they return a 0 if both 0 then it returns a 0
    ////////////////////////////// END OF ADD OKAY
    int sumSign = !((sum >> 31) & 0x1); // sets sumsign eqial to the true or false of the shifted sum which gets ride of the 31 bits and only keeps the most sig bit and then or'ed with 1 so that we get either get a 1 returned or if the most sig was a zero then then it will return 0. Then what that means is the ! infront switches that to a a 1 or a 0. This will be helpful later when we are trying to determine what the sign of the sig bit should be.
    mask = (!overflow + ~0x00); // so reduce the overflow value to a 0 or a 1 if it holds all 0s then it will return a 1 if it holds even just 1 1 then it will return 0, then adds that to a not'ed zeros to get all 1s thus determining ////////////////////////// 
    int mask2 = (!sumSign +  ~0x00); //////////
    T = ((~mask2) & V) | ((mask2) & a); ////////// 
    mask = ((~mask) & test1) | ((mask) & T ); /////////////
    return mask;
}
*/