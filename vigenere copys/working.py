{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys\n",
    "MAX_KEY_LENGTH_GUESS = 20\n",
    "alphabet = 'abcdefghijklmnopqrstuvwxyz'\n",
    "\n",
    "# Array containing the relative frequency of each letter in the English language\n",
    "english_frequences = [0.08167, 0.01492, 0.02782, 0.04253, 0.12702, 0.02228, 0.02015,\n",
    "\t\t\t\t\t  0.06094, 0.06966, 0.00153, 0.00772, 0.04025, 0.02406, 0.06749,\n",
    "\t\t\t\t\t  0.07507, 0.01929, 0.00095, 0.05987, 0.06327, 0.09056, 0.02758,\n",
    "\t\t\t\t\t  0.00978, 0.02360, 0.00150, 0.01974, 0.00074]\n",
    "\n",
    "# Returns the Index of Councidence for the \"section\" of ciphertext given\n",
    "\n",
    "\n",
    "def main():\n",
    "\t# ciphertext_unfiltered = input(\"Enter ciphertext to decrypt: \")\n",
    "\t# ciphertext = ''.join(x.lower() for x in ciphertext_unfiltered if x.isalpha())\n",
    "\tkey_length=get_key_length(cipher)\n",
    "\tprint(\"Key length is most likely {}\".format(key_length))\n",
    "\tkey = get_key(ciphertext, key_length)\n",
    "\tplaintext = decrypt(ciphertext, key)\n",
    "\tprint(\"Plaintext: {}\".format(plaintext))\n",
    "\n",
    "if __name__ == '__main__':\n",
    "\tcipher = sys.stdin.read().replace(\"\\n\", \"\").replace(\" \", \"\").upper()\n",
    "\t\n",
    "\tdef get_index_c(ciphertext):\n",
    "\n",
    "\t\tN = float(len(ciphertext))\n",
    "\t\tfrequency_sum = 0.0\n",
    "\n",
    "\t\t# Using Index of Coincidence formula\n",
    "\t\tfor letter in alphabet:\n",
    "\t\t\tfrequency_sum+= ciphertext.count(letter) * (ciphertext.count(letter)-1)\n",
    "\n",
    "\t\t# Using Index of Coincidence formula\n",
    "\t\tic = frequency_sum/(N*(N-1))\n",
    "\t\treturn ic\n",
    "\n",
    "\t# Returns the key length with the highest average Index of Coincidence\n",
    "\tdef get_key_length(ciphertext):\n",
    "\t\tic_table=[]\n",
    "\n",
    "\t\t# Splits the ciphertext into sequences based on the guessed key length from 0 until the max key length guess (20)\n",
    "\t\t# Ex. guessing a key length of 2 splits the \"12345678\" into \"1357\" and \"2468\"\n",
    "\t\t# This procedure of breaking ciphertext into sequences and sorting it by the Index of Coincidence\n",
    "\t\t# The guessed key length with the highest IC is the most porbable key length\n",
    "\t\tfor guess_len in range(MAX_KEY_LENGTH_GUESS):\n",
    "\t\t\tic_sum=0.0\n",
    "\t\t\tavg_ic=0.0\n",
    "\t\t\tfor i in range(guess_len):\n",
    "\t\t\t\tsequence=\"\"\n",
    "\t\t\t\t# breaks the ciphertext into sequences\n",
    "\t\t\t\tfor j in range(0, len(ciphertext[i:]), guess_len):\n",
    "\t\t\t\t\tsequence += ciphertext[i+j]\n",
    "\t\t\t\tic_sum+=get_index_c(sequence)\n",
    "\t\t\t# obviously don't want to divide by zero\n",
    "\t\t\tif not guess_len==0:\n",
    "\t\t\t\tavg_ic=ic_sum/guess_len\n",
    "\t\t\tic_table.append(avg_ic)\n",
    "\n",
    "\t\t# returns the index of the highest Index of Coincidence (most probable key length)\n",
    "\t\tbest_guess = ic_table.index(sorted(ic_table, reverse = True)[0])\n",
    "\t\tsecond_best_guess = ic_table.index(sorted(ic_table, reverse = True)[1])\n",
    "\n",
    "\t\t# Since this program can sometimes think that a key is literally twice itself, or three times itself,\n",
    "\t\t# it's best to return the smaller amount.\n",
    "\t\t# Ex. the actual key is \"dog\", but the program thinks the key is \"dogdog\" or \"dogdogdog\"\n",
    "\t\t# (The reason for this error is that the frequency distribution for the key \"dog\" vs \"dogdog\" would be nearly identical)\n",
    "\t\tif best_guess % second_best_guess == 0:\n",
    "\t\t\treturn second_best_guess\n",
    "\t\telse:\n",
    "\t\t\treturn best_guess\n",
    "\n",
    "\t# Performs frequency analysis on the \"sequence\" of the ciphertext to return the letter for that part of the key\n",
    "\t# Uses the Chi-Squared Statistic to measure how similar two probability distributions are.\n",
    "\t# (The two being the ciphertext and regular english distribution)\n",
    "\tdef freq_analysis(sequence):\n",
    "\t\tall_chi_squareds = [0] * 26\n",
    "\n",
    "\t\tfor i in range(26):\n",
    "\n",
    "\t\t\tchi_squared_sum = 0.0\n",
    "\n",
    "\t\t\t#sequence_offset = [(((seq_ascii[j]-97-i)%26)+97) for j in range(len(seq_ascii))]\n",
    "\t\t\tsequence_offset = [chr(((ord(sequence[j])-97-i)%26)+97) for j in range(len(sequence))]\n",
    "\t\t\tv = [0] * 26\n",
    "\t\t\t# count the numbers of each letter in the sequence_offset already in ascii\n",
    "\t\t\tfor l in sequence_offset:\n",
    "\t\t\t\tv[ord(l) - ord('a')] += 1\n",
    "\t\t\t# divide the array by the length of the sequence to get the frequency percentages\n",
    "\t\t\tfor j in range(26):\n",
    "\t\t\t\tv[j] *= (1.0/float(len(sequence)))\n",
    "\n",
    "\t\t\t# now you can compare to the english frequencies\n",
    "\t\t\tfor j in range(26):\n",
    "\t\t\t\tchi_squared_sum+=((v[j] - float(english_frequences[j]))**2)/float(english_frequences[j])\n",
    "\n",
    "\t\t\t# add it to the big table of chi squareds\n",
    "\t\t\tall_chi_squareds[i] = chi_squared_sum\n",
    "\n",
    "\t\t# return the letter of the key that it needs to be shifted by\n",
    "\t\t# this is found by the smallest chi-squared statistic (smallest different between sequence distribution and\n",
    "\t\t# english distribution)\n",
    "\t\tshift = all_chi_squareds.index(min(all_chi_squareds))\n",
    "\n",
    "\t\t# return the letter\n",
    "\t\treturn chr(shift+97)\n",
    "\tdef get_key(ciphertext, key_length):\n",
    "\t\tkey = ''\n",
    "\n",
    "\t\t# Calculate letter frequency table for each letter of the key\n",
    "\t\tfor i in range(key_length):\n",
    "\t\t\tsequence=\"\"\n",
    "\t\t\t# breaks the ciphertext into sequences\n",
    "\t\t\tfor j in range(0,len(ciphertext[i:]), key_length):\n",
    "\t\t\t\tsequence+=ciphertext[i+j]\n",
    "\t\t\tkey+=freq_analysis(sequence)\n",
    "\n",
    "\t\treturn key\n",
    "\n",
    "\t# Returns the plaintext given the ciphertext and a key\n",
    "\tdef decrypt(ciphertext, key):\n",
    "\t\t# Creates an array of the ascii values of the ciphertext and the key\n",
    "\t\tcipher_ascii = [ord(letter) for letter in ciphertext]\n",
    "\t\tkey_ascii = [ord(letter) for letter in key]\n",
    "\t\tplain_ascii = []\n",
    "\n",
    "\t\t# Turns each ascii value of the ciphertext into the ascii value of the plaintext\n",
    "\t\tfor i in range(len(cipher_ascii)):\n",
    "\t\t\tplain_ascii.append(((cipher_ascii[i]-key_ascii[i % len(key)]) % 26) +97)\n",
    "\n",
    "\t\t# Turns the array of ascii values into characters\n",
    "\t\tplaintext = ''.join(chr(i) for i in plain_ascii)\n",
    "\t\treturn plaintext\n",
    "\tmain()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
